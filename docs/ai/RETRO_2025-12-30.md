# Retro (2025-12-30)

Team: Product Lead, UI/UX Lead, Flutter Engineering Lead

## What we set out to do
- Stabilize the dashboard and Places Hero work so we can transition into a new chat without losing momentum.
- Reduce “compile churn” by tightening our patch discipline, tests, and documentation handoff.
- Keep the dashboard redesign direction intact (hero at top, scrollable grid below, tool widgets as tiles, empty grid slots as +).

## What went well
- The overall dashboard direction is coherent and implementable: a static hero anchored to the grid, with the rest of the dashboard as a scrollable tile board.
- Keys and test affordances exist (or are being standardized) so we can keep UI iteration safe.
- We’ve been consistently capturing operational guardrails in `docs/ai/WORKING_WITH_CHATGPT.md`, which is paying off as changes stack up.

## What didn’t go well
- **Layout fragility on small surfaces:** a few UI areas behaved as if they had more space than they actually did, leading to RenderFlex overflows in tests.
- **Constraint assumptions:** the Places Hero parent’s compact decision did not always match the child block’s real constraints.
- **Minor tech-debt friction:** deprecations (Color.withOpacity), plus small analyzer hygiene issues (unused imports, unnecessary `!`) kept resurfacing and distracting.

## What we changed in this wrap-up patch
- Dashboard AppBar leading no longer uses a `Row` (prevents unbounded width). It uses a constrained `Column`, centers vertically, and ellipsizes the refreshed label safely.
- Removed an unused import and removed a redundant non-null assertion.
- Replaced deprecated `withOpacity` usage with `withAlpha(...)`.
- Places Hero left block now uses `LayoutBuilder` to compute an **effective compact mode** from real constraints; it will choose the compact layout when the block is physically tight, even if the parent isn’t compact.

## Decisions we are locking in
- **Compact layouts are constraint-driven, not assumption-driven.** Critical tiles must compute compactness internally if they can be nested inside variable containers.
- **Patch protocol stays strict:** every patch zip must include `docs/ai/context_db.json` updates and a patch_tracking entry.
- **UI work must be backed by tests:** any dashboard UI change must keep widget tests passing, or include test refactors in the same patch.

## Action items for the next slice
1) Dashboard grid rework
- Implement the scrollable tile board with visible + placeholders for empty slots.
- Define the four default “high-impact” tools to ship first (and keep the rest discoverable via the top-right tool list/menu).

2) Tool widget modals
- For Height, Baking, Liquids, Area: modal layout is split into input (top half) and history log (bottom 1/2 to 1/3).
- Keep the last 10 executions with units and results; prefer a small list with stable keys for tests.

3) Theme hygiene pass
- Do a head-to-toe audit for Dracula color usage consistency across text styles and surfaces.

4) Dependency + analyzer cleanup
- Resolve pubspec constraint drift when we return to sustaining engineering (packages with newer incompatible versions).

## Risks
- If we continue to rely on parent-derived compact booleans, we will keep rediscovering overflows. Use internal constraints for any “tile-budgeted” widget.
- If we make large UI rewrites without extracting sub-widgets, we will reintroduce compile churn.
